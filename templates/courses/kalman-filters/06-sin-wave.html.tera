<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Kalman Filter of Sin Wave</title>
    <link rel="stylesheet" type="text/css" href="/css/style.css">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>

    <header>
        <h1>Tracking a Sin Wave with a Kalman Filter</h1>
    </header>

    {% include "utils/nav" %}

    <main>

        \[ \newcommand{\Lagr}{\mathscr{L}} \]

        <p>
            The sin wave tracking problem presents us with a unique opportunity.
            There are many possible solutions to this problem, some linear and
            some non-linear. This allows us to see the effect of different kinds
            of Kalman filters in action
        </p>

        <p>
            First, let's just quickly write a simple method which generates
            data which we can use in all the examples for the sin wave.
        </p>

        <pre>
            <code>
pub fn get_data() -> Data {
    let mut t_hist = vec![];
    let mut y_hist = vec![];
    let mut y_m = vec![];
    let mut t = 0.0;

    let normal = Normal::new(0.0, R).unwrap();
    let mut rng = rand::thread_rng();

    for _ in 0..1000 {
        let y = A * (OMEGA * t).sin();

        t_hist.push(t);
        y_hist.push(y);
        y_m.push(y + normal.sample(&mut rng));

        t += TS;
    }

    return Data {
        t: t_hist,
        y: y_hist,
        y_m: y_m,
    };
}

pub struct Data {
    pub t: Vec&lt;f64>,
    pub y: Vec&lt;f64>,
    pub y_m: Vec&lt;f64>,
}
            </code>
        </pre>

        <p>
            Just like in our other problems, this allows us to test against noisy
            measurements. Recall that#
        </p>

        \[ x = \sin(\omega t) \]

        <h2>Linear First Order</h2>

        <p>
            We begin with the simplest case for the sin wave tracking problem -
            linear and first order tracking. We understand that the measurements
            will be given by
        </p>

        \[ x^* = \sin(\omega t) + \nu \]

        <p>
            Where \(\nu\) is some noise. Looking at the derivatives we have
        </p>

        \[ x = \sin(\omega t) \]
        \[ \dot{x} = \sin(\omega t) \]

        <p>
            We've already handled linear first order problems before, so I won't
            spend too much time on the details. Suffice to say, we've already
            seen all of the relevant matricies before.
        </p>

        \[
        \mathbf{\Phi}_k =

        \begin{bmatrix}
        1 & dt \\
        0 & 1
        \end{bmatrix}

        \]

        \[

        \mathbf{H} =

        \begin{bmatrix}
        1 & 0
        \end{bmatrix}


        \]

        \[

        \mathbf{Q}_k =

        \Phi_s

        \begin{bmatrix}
        \frac{dt^3}{3} & \frac{dt^2}{2} \\
        \frac{dt^2}{2} & dt
        \end{bmatrix}

        \]

        <p>
            With that, we can define
        </p>

        \[\tilde{x}_k = x^*_k - \hat{x}_{k-1} - dt \hat{\dot{x}}_{k-1} \]

        <p>
            So that we can use the following solutions
        </p>

        \[ \hat{x}_k = \hat{x}_{k-1} + dt \hat{\dot{x}}_{k-1} + K_1 \tilde{x}_k \]

        \[ \hat{\dot{x}} = \hat{\dot{x}}_{k-1} + K_2 \tilde{x}_k \]

        <p>
            And we get the following results which...
        </p>

        <h2>Linear Second Order</h2>

        <p>
            Let's now try a linear second order filter. Again, we've see the
            derivation of a second order filter before, so I'll just remind
            you of the relevant results.
        </p>

        \[

        \mathbf{\Phi}_k =

        \begin{bmatrix}
        1 & dt & 0.5 dt^2 \\
        0 & 1 & dt \\
        0 & 0 & 1
        \end{bmatrix}

        \]

        \[

        \mathbf{H} =

        \begin{bmatrix}
        1 & 0 & 0
        \end{bmatrix}

        \]

        \[

        \mathbf{Q}_k =

        \Phi_s
        \begin{bmatrix}
        \frac{dt^5}{20} & \frac{dt^4}{8} & \frac{dt^3}{6} \\
        \frac{dt^4}{8} & \frac{dt^3}{3} & \frac{dt^2}{2} \\
        \frac{dt^3}{6} & \frac{dt^2}{2} & dt
        \end{bmatrix}

        \]

        <p>
            We can then define
        </p>

        \[ \tilde{x} = x^*_k - \hat{x}_{k-1} - dt \hat{\dot{x}}_{k-1} - 0.5 dt^2 \hat{\ddot{x}}_{k-1} \]

        <p>
            So now we can solve the equations to give
        </p>

        \[ \hat{x} = \hat{x}_{k-1} + dt \hat{\dot{x}}_{k-1} + 0.5 dt^2 \hat{\ddot{x}}_{k-1} + K_1 \tilde{x} \]

        \[ \hat{\dot{x}} = \hat{\dot{x}}_{k-1} + dt \hat{\ddot{x}}_{k-1} + K_2 \tilde{x} \]

        \[ \hat{\ddot{x}} = \hat{\ddot{x}}_{k-1} + K_3 \tilde{x} \]

        <p>
            Which gives the following results, which are...
        </p>

        <h2>Linear Filter with A Priori Information</h2>

        <p>
            In this variation, we're going to help the filter out by giving it
            some additional information. We'll have a slightly different state
            matrix. Let's start by remembering the fundamentals of oscillations.
        </p>

        \[ x = A \sin(\omega t) \]

        \[ \dot{x} = A \omega \cos(\omega t) \]

        \[ \ddot{x} = -A \omega^2 \sin(\omega t) \]

        <p>
            Which means we can rewrite the second derivative using the first
            equation like so
        </p>

        \[ \ddot{x} = -\omega^2 x \]

        <p>
            Using this, we can form a new state-space equation
        </p>

        \[

        \begin{bmatrix}
        \dot{x} \\
        \ddot{x}
        \end{bmatrix}

        =

        \begin{bmatrix}
        0 & 1 \\
        -\omega^2 & 0
        \end{bmatrix}

        \begin{bmatrix}
        x \\
        \dot{x}
        \end{bmatrix}

        \]

        <p>
            By inspection we can see that
        </p>

        \[

        \mathbf{F} =

        \begin{bmatrix}
        0 & 1 \\
        -\omega^2 & 0
        \end{bmatrix}

        \]

        <p>
            Unfortunately, in this case the derivations are not so simple of the
            \(\Phi\) matrix. We know that
        </p>

        \[

        \mathbf{\Phi}(t) = \Lagr ((\mathbf{s} \mathbf{I} - \mathbf{F}^{-1}))

        \]

        <p>
            The Laplace transform is tricky, but we can start with the matrix
            manipulation
        </p>

        \[ \mathbf{s} \mathbf{I} =

        \begin{bmatrix}
        s & 0 \\
        0 & s
        \end{bmatrix}

        \]

        \[

        \mathbf{s} \mathbf{I} - \mathbf{F} =

        \begin{bmatrix}
        s & -1 \\
        \omega^2 & s
        \end{bmatrix}

        \]

        <p>
            We can now inverse this to give<sup><a href="#footnote1">1</a></sup>
        </p>

        \[

        (\mathbf{s} \mathbf{I} - \mathbf{F})^{-1} =

        \frac{1}{s^2 + \omega^2}
        \begin{bmatrix}
        s & 1 \\
        -\omega^2 & s
        \end{bmatrix}

        \]

        <p>
            The Laplace itself is tricky. For most real world problems, the
            Laplace will be too challenging to actually perform by itself.
            Typically, we would use reference tables to perform the Laplace
            transform. A useful book to have a copy of for this purpose if you
            plan on making original Kalman filters is <i>CRC Standard Mathematical
                Tables and Formulas</i> 33rd Edition by Dan Zwillinger
        </p>

        \[ \Phi(t) =

        \begin{bmatrix}
        \cos(\omega t) & \sin(\omega t) / \omega \\
        -\omega \sin(\omega t) & \cos(\omega t)
        \end{bmatrix}

        \]

        <p>
            We are now in a position to solve the Riccati equations. We define a
            residual as
        </p>

        \[\tilde{x} = x^*_k - \cos(\omega dt) \hat{x}_{k-1} - \frac{\sin(\omega dt)}{\omega} \hat{\dot{x}}_{k-1} \]

        <p>
            And the solutions as
        </p>

        \[ \hat{x}_k = \cos(\omega dt) \hat{x}_{k-1} + \frac{\sin(\omega dt)}{\omega} \hat{\dot{x}}_{k-1} + K_1
        \tilde{x} \]

        \[ \hat{\dot{x}}_k = -\omega \sin(\omega dt) \hat{x}_{k-1} + \cos(\omega dt) \hat{\dot{x}}_{k-1} + K_2 \tilde{x}
        \]

        <p>
            We get the following results for this solution which are...
        </p>

        <h2>Extended Kalman Filter Solution</h2>

        <p>
            Since this variation is non-linear, we can expect to have a non-linear
            state. Returning to the equations for oscillation again
        </p>

        \[x = A \sin(\omega t)\]

        <p>
            We bring back the amplitude \(A\) for this section. We define a new
            variable \(\theta = \omega t\). If the frequency is constant (which
            we will assume so for this example) then \( \dot{\theta} = \omega\)
            and \( \dot{\omega} = 0 \). We will also assume constant amplitude,
            so \( \dot{A} = 0\). Therefore, the state-space equations are given
            by
        </p>

        \[

        \begin{bmatrix}
        \dot{\theta} \\
        \dot{\omega} \\
        \dot{A}
        \end{bmatrix}

        =

        \begin{bmatrix}
        0 & 1 & 0 \\
        0 & 0 & 0 \\
        0 & 0 & 0
        \end{bmatrix}

        \begin{bmatrix}
        \theta \\
        \omega \\
        A
        \end{bmatrix}

        +

        \begin{bmatrix}
        0 \\
        u_{s1} \\
        u_{s2}
        \end{bmatrix}

        \]

        <p>
            This state-space equation is interesting in the noise component. We
            introduce two different spectral densities. This is because the noise
            in \(\omega\) might not be the same as the noise in \(A\). In general
            \(u_{s1} \neq u_{s2}\). This imapcts how we derive \(\mathbf{Q}_k\)
            slighlty.
        </p>

        \[

        \mathbf{Q} =

        \begin{bmatrix}
        0 & 0 & 0 \\
        0 & \Phi_{s1} & 0 \\
        0 & 0 & \Phi_{s2}
        \end{bmatrix}

        \]

        <p>
            We can continue the derivation of \(\mathbf{Q}_k\) after finding the
            fundamental matrix.
        </p>

        \[

        \mathbf{F} =

        \begin{bmatrix}
        0 & 1 & 0 \\
        0 & 0 & 0 \\
        0 & 0 & 0
        \end{bmatrix}

        \]

        <p>
            Thankfully, this is a quite easy to derive the fundamental matrix in
            this instance because
        </p>

        \[

        \mathbf{F}^2 =

        \begin{bmatrix}
        0 & 0 & 0 \\
        0 & 0 & 0 \\
        0 & 0 & 0
        \end{bmatrix}

        \]

        <p>
            Therefore, we can use the Taylor expansion to find the fundamental
            matrix
        </p>

        \[

        \mathbf{\Phi}(t) = \mathbf{I} + \mathbf{F} t =

        \begin{bmatrix}
        1 & t & 0 \\
        0 & 1 & 0 \\
        0 & 0 & 1
        \end{bmatrix}

        \]

        \[

        \mathbf{Q}_k = \int^{T_s}_0 \mathbf{\Phi} (\tau) \mathbf{Q} \mathbf{\Phi}^T (\tau) d \tau

        \]

        \[

        \mathbf{Q}_k = \int^{T_s}_0

        \begin{bmatrix}
        1 & \tau & 0 \\
        0 & 1 & 0 \\
        0 & 0 & 1
        \end{bmatrix}

        \begin{bmatrix}
        0 & 0 & 0 \\
        0 & \Phi_{s1} & 0 \\
        0 & 0 & \Phi_{s2}
        \end{bmatrix}

        \begin{bmatrix}
        1 & 0 & 0 \\
        \tau & 1 & 0 \\
        0 & 0 & 1
        \end{bmatrix}

        d \tau

        \]

        \[

        \mathbf{Q}_k = \int^{T_s}_0

        \begin{bmatrix}
        \tau^2 \Phi_{s1} & \tau \Phi_{s1} & 0 \\
        \tau \Phi_{s1} & \Phi_{s1} & 0 \\
        0 & 0 & \Phi_{s2}
        \end{bmatrix}

        d \tau

        \]

        \[

        \mathbf{Q}_k =

        \begin{bmatrix}
        \frac{\Phi_{s1} dt^3}{3} & \frac{\Phi_{s1} dt^2}{2} & 0 \\
        \frac{\Phi_{s1} dt^2}{2} & \Phi_{s1} dt & 0 \\
        0 & 0 & \Phi_{s2} dt
        \end{bmatrix}

        \]

        <p>
            Finally, coming to the actual non-linear part we will need to do
            partial derivatives. Since
        </p>

        \[

        \Delta x^* =

        \begin{bmatrix}
        \frac{\partial x}{\partial \theta} \frac{\partial x}{\partial \omega} \frac{\partial x}{\partial A}
        \end{bmatrix}

        \begin{bmatrix}
        \Delta \theta \\
        \Delta \omega \\
        \Delta A
        \end{bmatrix}

        + \nu

        \]

        <p>
            Since \(x = S \sin(\omega t) = A \sin(\theta) \) then
        </p>

        \[ \frac{\partial x}{\partial \theta} = A \cos(\theta) \]

        \[ \frac{\partial x}{\partial \omega} = 0 \]

        \[ \frac{\partial x}{\partial A} = \sin(\theta) \]

        <p>
            Which gives us \(\mathbf{H}\) as
        </p>

        \[

        \mathbf{H} =

        \begin{bmatrix}
        A \cos(\theta) & 0 & \sin{\theta}
        \end{bmatrix}

        \]

        <p>
            We are finally in a position to begin solving the Riccati equations!
            Frist, we define the predicted values
        </p>

        \[

        \begin{bmatrix}
        \bar{\theta}_k \\
        \bar{\omega}_k \\
        \bar{A}_k
        \end{bmatrix}

        =

        \begin{bmatrix}
        1 & dt & 0 \\
        0 & 1 & 0 \\
        0 & 0 & 1
        \end{bmatrix}

        \begin{bmatrix}
        \hat{\theta}_{k-1} \\
        \hat{\omega}_{k-1} \\
        \hat{A}_{k-1}
        \end{bmatrix}

        \]

        \[ \bar{\theta}_k = \hat{\theta}_{k-1} + \hat{\omega}_{k-1} dt \]

        \[ \bar{\omega}_k = \hat{\omega}_{k-1} \]

        \[ \hat{A}_k = \hat{A}_{k-1} \]

        <p>
            Note, that it is these bar values which you will use for \mathbf{H}
        </p>

        <p>
            We define a residual as
        </p>

        \[ \tilde{x} = x^*_k - \bar{A}_k \sin(\bar{\theta}_k) \]

        <p>
            And the final solutions are
        </p>

        \[ \hat{\theta}_k = \bar{\theta}_k + K_1 \tilde{x} \]

        \[ \hat{\omega}_k = \bar{\omega}_k + K_2 \tilde{x} \]

        \[ \hat{A}_k = \bar{A}_k + K_3 \tilde{x} \]

        <p>
            Here's the results from this simulation which show that...
        </p>

        <h2>Footnote</h2>

        <p id="footnote1">
            My primary reference on this section
            <i>Fundamnetals of Kalman Filtering: A Practical Approach</i>
            3rd Edition by Paul Zarchan, Howard Musoff and Frank K. Lu
            lists the solution to the inverse as
            \( \frac{1}{s^ + \omega^2} \begin{bmatrix} s & 1 \\ -\omega^2 & 1 \end{bmatrix} \),
            however, by the standard convention of matrix inverse, you get my
            solution with the \(s\) in the bottom right hand corner. WolframAlpha
            agrees with my derivation, so I will list it as the correct version here.
            I think that the final Laplace transform matrix for \(\Phi(t)\)
            is correct as given, but I will continue to investigate. Many
            people online agree on \(\Phi(t)\) for this problem, but maybe
            they are just using Zarchan as reference without digging deeper.
            I will try and keep this up to date if I find any more information
            on this.
        </p>

    </main>

    <script src="/js/highlight/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

</body>

</html>